{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 To my personal collection of notes with the things I learn on my way. Vertical Slicing React Architecture definitions","title":"Welcome"},{"location":"#welcome","text":"To my personal collection of notes with the things I learn on my way. Vertical Slicing React Architecture definitions","title":"Welcome"},{"location":"Architecture%20definitions/","text":"Reasoning about the Data Flows within different components of a software system is the central idea of software architecture. Contemporary front-end architectures La arquitectura es el conjunto de decisiones que son dif\u00edciles de cambiar. https://docs.google.com/presentation/d/1mkWPRN56PIdKw60WmzcrCM28WU04e_18Tv1Jg0ZVzzY/edit#slide=id.g6ec24d55e2_0_25 Quote of the Week: \u201cProgramming without an overall architecture or design in mind is like exploring a cave with only a flashlight: You don\u2019t know where you\u2019ve been, you don\u2019t know where you\u2019re going, and you don\u2019t know quite where you are.\u201d \u2014 Danny Thorpe, Software Engineer and major contributor to the Delphi programming language Software architecture is the art of putting things in the right place so that you can find them at the right time. https://twitter.com/talkingbit1/status/1372190827603197963 Ralph Johnson famously defined software architecture as \u201cthe important stuff (whatever that is).\u201d Ford, Neal, Rebecca Parsons, and Patrick Kua. \u201cBuilding Evolutionary Architectures,\u201d n.d., 190. software architecture is defined as the \u201cparts hard to change later.\u201d Ford, Neal, Rebecca Parsons, and Patrick Kua. \u201cBuilding Evolutionary Architectures,\u201d n.d., 190.","title":"Architecture definitions"},{"location":"React/","text":"React I have using React for a while, since 2014 when we created Refly. React brought a lot of simplicity at that time, other frameworks, like Angular, tried to solve too much, imitating desktop app frameworks. However, with React, there was always something missing in the whole picture, some kind of guidance, architecture, organization. We didn't know, but solutions as flux, flex, reflux, Redux, etc. seemed to fill the gap, but adding complexity and new artifacts. In Creditlinks we mix React component with views rendered in the Python backend, and we didn't use any library to organize the complexity around React components. Fortunately, they didn't grow enough to create a problem for us. From the very beginning I tried to use functional components and avoid class component, I guess that's why hooks looked so good to me when they were released. However, after working with them in a big base of code, I quickly came to the conclusion that far from reducing the complexity, they make my code much more coupled. That was the time when I started thinking more on what React is and how to use it properly. The following are my conclusions so far. React is a reactive components' library. A component describe a composable behavior. The React's team decided to include component's rendering, lifecycle and state inside the library to handle these concerns in a common way. React's components can listen to events to exercise some view logic and update their internal state or children properties. React's components react to changes in their properties or internal state, updating the DOM. That's all. So, why we started using it in a different way? Put too much logic in our UI/Components/whatever is a common mistake. Maybe that was the reason because the React's team came out with hooks, but it didn't make it better. The way for getting data from the outside world into the components was through the effect hook, and with it, all the problem came. The documentation proposed to make a fetch inside an effect with an empty dependency array. Sooner or later, we take advantage of it to add some transformations or even some domain logic and adding new dependencies on the dependencies' array and some logic to decide what was the reason because the effect was executed. Actually, what we were doing was to use effects to orchestrate our app, something React wasn't designed for. But, what do I mean by logic and why is so bad to put too much into the components? I am going to distinguish between three types of logic: View logic: The checks that drive changes in our UI, i.e., when a value is higher than 5, change the color to red Orchestration logic: The logic that controls the different paths the execution can take. Business logic: The solution to the issue we want to solve. According to react documentation, components created by different people should work well together. If you put orchestration logic or business logic inside your component, chances are that you break that rule. But even if this is not important to you, you must be aware that you are including unnecessary complexity inside your components and this complexity will push you to do things for what React components are not designed. Business logic lead you to move application state into component state, when you add state for what the component should not react your only option is to start writing orchestration logic inside the components, and then synchronization issues start appearing. What if we stop using effects at all. Is it even possible? I think so. The new React's documentation explores some of these misused. But, what about those things you have to do when a component is displayed? We don't really need an effect for that, we only need an event to subscribe a handler. IMHO this approach is clearer and more consistent and in the end easier to explain and understand. React doesn't support it, but I think it isn't difficult to create a component that trigger an event when the component has been loaded. React covers a small space in web application development, if we keep it in charge of the things it was created for we would have much fewer problems: Better performance Simpler code Fast and simple tests","title":"React"},{"location":"Vertical%20Slicing/","text":"If you only want the highlights here they are: It's about developing incrementally The challenge is to find the right increments Separate problem from solution Value is what we want There is always more than one way to get there Use it to guide implementation Reduce scope doing engineering An increment implementation without quality is a spike Don't release each slice if you want to know a bit more, continue reading. Why? \u00b6 Developing is a researching process and vertical slicing provides us with a tool to apply the scientific model to this process. We make hypothesis and get fast feedback to validate or reject them. Additionally, through the development of narrow slices we can provide value sooner and react to changes or error faster. We start digging into this topic because we think we can improve our delivery rate narrowing the scope of our user stories. How? \u00b6 To start learning about this topic we follow the guide wrote by Abraham Vallez 1 . It's very recommendable and not only because it is easy to read and to understand, but as well because it's full of references where you can learn much more. Before starting, you should try to forget anything you know about other techniques and focus on what Abraham tells. There will be time to look for similitudes and contradictions, but if you don't want to spend the reading fighting with you preconceived ideas I totally recommend you start with a fresh mindset. I think I am not spoiling the party if I advance you some of the main ideas I have gotten from these readings: An increment provides value if it gives us feedback to reach our final goals As Ron Jeffries explain in \"The Nature of Software Development\" 2 value is what we want, what matters to us, and it isn't only one thing. Usually there are a bunch of things that are important for the team and feedback is one of them. If the output of the slice is real software working whose outcome is any kind of information we can consider that the increment is good enough. Separate the problem space from the solution space When it comes to decomposing a problem into activities, complexities, and variations it's essential to keep separated the problem from the solution. We developers are accustomed to run towards the solution mixing everything and narrowing the spectrum of results that we can offer. In that process the simplest solutions used to vanishing. Apply different levels of abstraction to different areas Vertical slicing is an iterative process. We start with a slice of the problem, and then we start developing a solution using vertical slicing. As we mentioned before these are two different arenas, and we need different mindsets to work in each of them. The right size of a slice is one which provides feedback No more, no less. Usually the difficulty isn't to find something extra to add, we are very good on that, but we need to remove the irrelevant keeping the essential to get the feedback we require. Lessons learned \u00b6 There is always more than one way to get there \u00b6 We repeated the exercise different days with different people. The slices were always different. To slice a problem is a kind of art. It takes time and practice to develop some skills to master this technique. The good thing was that none of the results was wrong. Furthermore, they were different in shape, but with a very similar intention and therefore a very similar result. Fortunately, there are some strategies to help us with it, for example SPIDR 3 offers us a framework to get some ideas about how to slice up our problem. Use it to guide the implementation \u00b6 Vertical slicing is not only about dividing the problem's space. It is about guiding the solution. We should implement small slices that give us quick feedback and allow us to move faster. It is tempting to split the user story once we have worked it out after a vertical slicing session. Front-end and back-end or React components and domain or Database model and whatever else you have. Although this approach works, it is easy to lose the big picture and get lost on technical details spoiling our initial intention of getting fast feedback through the simpler solution. I remember a road that would enjoin Portada Alta with Malaga's University, they started building the road by both ends hoping to meet in the middle. However, when they reach the planned point both roads didn't match they had to create an impossible curve to communicate both roads. If that happens in an industry with years of experience, procedures, techniques and backed by physics and maths it isn't difficult to see why it isn't the best approach for us. Reduce the scope doing engineering \u00b6 We can't reduce the value. We have chosen an increment that produces the value we are looking for, but we can reduce the technical scope. Applying engineering, thinking more and coding less, producing the same outcome with less output. This doesn't mean reduce the quality as we will see below. \"Build what you must, buy what you can, and write it all down\" ( 4 ) An increment implementation without quality is a spike \u00b6 To make vertical slicing works we must keep our code in good shape. If we are only concerned about fast delivery, sooner than later we will start running into our own code. The only way we can achieve its promise is finding a balance among technical excellence, simplicity and feasible solutions. How to get that balance is a topic for other post, but meanwhile, if you need help, take a look to XP. Don't release each slice \u00b6 Not every increment has to be releasable. Independently if you are doing CD or not, or what is your branching strategy you have mechanism to hide these increments at the same time you still can get feedback. Feature flags are a good tool on this regard, but you have others. The most important thing is to understand that every increment should not constitute a release, keep it in mind when you start practicing this. Conclusion \u00b6 As a product team our duty is to deliver value as soon as possible through a simple and high quality solution. Vertical slicing help us on getting the former, but is impossible without having the latter.","title":"Vertical Slicing"},{"location":"Vertical%20Slicing/#why","text":"Developing is a researching process and vertical slicing provides us with a tool to apply the scientific model to this process. We make hypothesis and get fast feedback to validate or reject them. Additionally, through the development of narrow slices we can provide value sooner and react to changes or error faster. We start digging into this topic because we think we can improve our delivery rate narrowing the scope of our user stories.","title":"Why?"},{"location":"Vertical%20Slicing/#how","text":"To start learning about this topic we follow the guide wrote by Abraham Vallez 1 . It's very recommendable and not only because it is easy to read and to understand, but as well because it's full of references where you can learn much more. Before starting, you should try to forget anything you know about other techniques and focus on what Abraham tells. There will be time to look for similitudes and contradictions, but if you don't want to spend the reading fighting with you preconceived ideas I totally recommend you start with a fresh mindset. I think I am not spoiling the party if I advance you some of the main ideas I have gotten from these readings: An increment provides value if it gives us feedback to reach our final goals As Ron Jeffries explain in \"The Nature of Software Development\" 2 value is what we want, what matters to us, and it isn't only one thing. Usually there are a bunch of things that are important for the team and feedback is one of them. If the output of the slice is real software working whose outcome is any kind of information we can consider that the increment is good enough. Separate the problem space from the solution space When it comes to decomposing a problem into activities, complexities, and variations it's essential to keep separated the problem from the solution. We developers are accustomed to run towards the solution mixing everything and narrowing the spectrum of results that we can offer. In that process the simplest solutions used to vanishing. Apply different levels of abstraction to different areas Vertical slicing is an iterative process. We start with a slice of the problem, and then we start developing a solution using vertical slicing. As we mentioned before these are two different arenas, and we need different mindsets to work in each of them. The right size of a slice is one which provides feedback No more, no less. Usually the difficulty isn't to find something extra to add, we are very good on that, but we need to remove the irrelevant keeping the essential to get the feedback we require.","title":"How?"},{"location":"Vertical%20Slicing/#lessons-learned","text":"","title":"Lessons learned"},{"location":"Vertical%20Slicing/#there-is-always-more-than-one-way-to-get-there","text":"We repeated the exercise different days with different people. The slices were always different. To slice a problem is a kind of art. It takes time and practice to develop some skills to master this technique. The good thing was that none of the results was wrong. Furthermore, they were different in shape, but with a very similar intention and therefore a very similar result. Fortunately, there are some strategies to help us with it, for example SPIDR 3 offers us a framework to get some ideas about how to slice up our problem.","title":"There is always more than one way to get there"},{"location":"Vertical%20Slicing/#use-it-to-guide-the-implementation","text":"Vertical slicing is not only about dividing the problem's space. It is about guiding the solution. We should implement small slices that give us quick feedback and allow us to move faster. It is tempting to split the user story once we have worked it out after a vertical slicing session. Front-end and back-end or React components and domain or Database model and whatever else you have. Although this approach works, it is easy to lose the big picture and get lost on technical details spoiling our initial intention of getting fast feedback through the simpler solution. I remember a road that would enjoin Portada Alta with Malaga's University, they started building the road by both ends hoping to meet in the middle. However, when they reach the planned point both roads didn't match they had to create an impossible curve to communicate both roads. If that happens in an industry with years of experience, procedures, techniques and backed by physics and maths it isn't difficult to see why it isn't the best approach for us.","title":"Use it to guide the implementation"},{"location":"Vertical%20Slicing/#reduce-the-scope-doing-engineering","text":"We can't reduce the value. We have chosen an increment that produces the value we are looking for, but we can reduce the technical scope. Applying engineering, thinking more and coding less, producing the same outcome with less output. This doesn't mean reduce the quality as we will see below. \"Build what you must, buy what you can, and write it all down\" ( 4 )","title":"Reduce the scope doing engineering"},{"location":"Vertical%20Slicing/#an-increment-implementation-without-quality-is-a-spike","text":"To make vertical slicing works we must keep our code in good shape. If we are only concerned about fast delivery, sooner than later we will start running into our own code. The only way we can achieve its promise is finding a balance among technical excellence, simplicity and feasible solutions. How to get that balance is a topic for other post, but meanwhile, if you need help, take a look to XP.","title":"An increment implementation without quality is a spike"},{"location":"Vertical%20Slicing/#dont-release-each-slice","text":"Not every increment has to be releasable. Independently if you are doing CD or not, or what is your branching strategy you have mechanism to hide these increments at the same time you still can get feedback. Feature flags are a good tool on this regard, but you have others. The most important thing is to understand that every increment should not constitute a release, keep it in mind when you start practicing this.","title":"Don't release each slice"},{"location":"Vertical%20Slicing/#conclusion","text":"As a product team our duty is to deliver value as soon as possible through a simple and high quality solution. Vertical slicing help us on getting the former, but is impossible without having the latter.","title":"Conclusion"}]}